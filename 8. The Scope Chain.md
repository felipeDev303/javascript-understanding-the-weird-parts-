# ğŸŸ¦ **The Scope Chain en JavaScript**

La **Scope Chain** (cadena de Ã¡mbitos) es el mecanismo que JavaScript utiliza para **buscar variables** cuando una lÃ­nea de cÃ³digo necesita acceder a una.

Es, literalmente, una **lista jerÃ¡rquica de entornos lÃ©xicos** (Lexical Environments) que se encadenan unos dentro de otros siguiendo dÃ³nde se escribiÃ³ el cÃ³digo (no dÃ³nde se ejecuta).

---

## ğŸŸ© **1. DefiniciÃ³n formal**

> **La Scope Chain es la cadena que conecta el Lexical Environment actual con todos sus entornos padres, permitiendo resolver variables desde el entorno mÃ¡s interno hacia el global.**

Esto ocurre porque **las funciones recuerdan el lugar donde fueron creadas**, no desde donde se llaman.

---

## ğŸŸ§ **2. CÃ³mo funciona la bÃºsqueda de variables**

Cuando el motor necesita un valor:

1. Revisa el **Environment Record** actual.
2. Si no lo encuentra, busca en el **Outer Environment**.
3. Y asÃ­ sucesivamente, subiendo por la cadenaâ€¦
4. â€¦hasta llegar al **Global Environment**.
5. Si no existe allÃ­ â†’ **ReferenceError**.

### ğŸ“Œ BÃºsqueda â†’ siempre desde adentro hacia afuera.

Nunca al revÃ©s.

---

## ğŸŸ© **3. Ejemplo bÃ¡sico**

```js
let a = 10;

function outer() {
  let b = 20;

  function inner() {
    let c = 30;
    console.log(a, b, c);
  }

  inner();
}
outer();
```

ğŸ” **Scope chain en `inner()`**:

```
inner LE
  â”œâ”€ c = 30
  â”œâ”€ outer LE
  â”‚     â”œâ”€ b = 20
  â”‚     â”œâ”€ global LE
  â”‚             â”œâ”€ a = 10
```

El motor hace:

- Â¿`c` estÃ¡ en `inner`? âœ” SÃ­
- Â¿`b` estÃ¡ en `outer`? âœ” SÃ­
- Â¿`a` estÃ¡ en global? âœ” SÃ­

---

## ğŸŸ¦ **4. Scope Chain vs Prototype Chain (para evitar confusiones)**

| Chain               | Para quÃ© sirve                | DirecciÃ³n                           |
| ------------------- | ----------------------------- | ----------------------------------- |
| **Scope Chain**     | Buscar variables              | Del contexto actual hacia fuera     |
| **Prototype Chain** | Buscar propiedades de objetos | Del objeto hacia su prototipo padre |

No tienen nada que ver, pero sus nombres suelen confundir.

---

## ğŸŸ§ **5. Â¿Por quÃ© existe la Scope Chain? (Causa real)**

Porque JavaScript usa un **Lexical Scope Model**:

- Las funciones capturan el **entorno donde fueron escritas**,
- no donde se ejecutan.

Esto permite:

- closures,
- funciones de orden superior,
- currying,
- programaciÃ³n funcional avanzada.

---

## ğŸŸª **6. AnalogÃ­a neurocientÃ­fica (la mÃ¡s precisa posible)**

Piensa en la Scope Chain como **la ruta de recuperaciÃ³n de memoria del cerebro**:

### ğŸ“Œ Cuando necesitas un dato (variable):

1. **Memoria de trabajo inmediata** (scope local)
   â€œÂ¿EstÃ¡ aquÃ­ mismo?â€

2. **Contexto donde aprendiste la tarea** (outer scope)
   â€œÂ¿DÃ³nde aprendÃ­ esto originalmente?â€

3. **Conocimiento general almacenado a largo plazo** (global scope)
   â€œÂ¿Forma parte del conocimiento universal que tengo?â€

Si no estÃ¡ en ninguno:
â¡ _â€œNo tengo ese conocimientoâ€_ â†’ ReferenceError

Es la misma lÃ³gica de un cerebro:

- Primero consulta _lo que tienes en activaciÃ³n actual_
- Si no, va a recuerdos asociados a tareas anteriores
- Luego al conocimiento general
- Si no existe, error cognitivo

---

## ğŸŸ© **7. VisualizaciÃ³n ASCII (muy clara)**

```
[Global Scope]
      â†“
[Outer Function Scope]
      â†“
[Inner Function Scope]  â† (Se ejecuta aquÃ­)
```

La bÃºsqueda ocurre de abajo hacia arriba:

```
Inner â†’ Outer â†’ Global
```

---

## ğŸŸ¦ **8. Ejemplo donde la Scope Chain se entiende perfecto**

```js
let x = 1;

function a() {
  let x = 2;

  function b() {
    console.log(x);
  }

  b();
}

a();
```

Salida:

```
2
```

Â¿Por quÃ© no imprime 1?

â¡ Porque la funciÃ³n **b** fue creada dentro de **a**, por lo que recuerda **ese lexical environment**, no el global.

Ejemplo clÃ¡sico de _closure_.

---

## ğŸŸª **Resumen definitivo**

**The Scope Chain** es:

- la columna vertebral del modelo de ejecuciÃ³n de JavaScript
- lo que permite closures
- lo que conecta todos los ambientes lÃ©xicos
- la razÃ³n por la que variables locales tienen prioridad
- la forma en que JS busca variables

Y su analogÃ­a cognitiva es:

- el proceso jerÃ¡rquico de recuperaciÃ³n de memoria humana.

---

Anterior tema: [Function, Context & Variable Environments](./7.%20Function%2C%20Context%20%26%20Variable%20Environments.md)
