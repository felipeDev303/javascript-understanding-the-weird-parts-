# Objects, Functions y `this` en JavaScript

JavaScript utiliza un modelo flexible en el que **objetos**, **funciones** y la palabra clave **`this`** están estrechamente relacionados. Comprender esta relación es esencial para manejar correctamente el comportamiento del código, especialmente en programación orientada a objetos, callbacks y métodos.

---

## 1. Objects en JavaScript

Un **objeto** es una colección de **pares clave–valor**, donde los valores pueden ser datos primitivos, otros objetos o funciones.

### Ejemplo básico:

```js
const usuario = {
  nombre: "Ana",
  edad: 30,
  saludar: function () {
    console.log("Hola");
  },
};
```

Características principales:

- Los objetos son **mutables**.
- Pueden contener cualquier tipo de dato.
- Se accede mediante `obj.prop` o `obj["prop"]`.
- Las funciones dentro de objetos se conocen como **métodos**.

---

## 2. Functions en JavaScript

Las funciones son ciudadanos de primera clase (**first-class citizens**), lo que significa:

- Se pueden guardar en variables.
- Se pueden pasar como argumentos.
- Se pueden retornar desde otras funciones.
- Pueden tener propiedades como cualquier objeto.

```js
function sumar(a, b) {
  return a + b;
}

sumar.descripcion = "Función que suma dos números";
```

Aunque sintácticamente parecen entidades especiales, **una función es un tipo de objeto** con:

- Un código ejecutable.
- Propiedades internas como `[[Environment]]`.
- Acceso a su propio `this`.

---

## 3. La palabra clave `this`

`this` siempre hace referencia a **un objeto**, pero su valor depende de **cómo** se ejecuta una función, no de dónde se declara.

### Reglas principales para `this`

#### 1. Llamada como método de objeto

`this` apunta al objeto que invoca el método.

```js
const persona = {
  nombre: "Juan",
  saludar() {
    console.log(this.nombre);
  },
};

persona.saludar(); // "Juan"
```

#### 2. Llamada como función simple

`this` apunta a:

- `undefined` en _strict mode_.
- `window` (o global) en modo no estricto.

```js
function f() {
  console.log(this);
}

f(); // undefined (strict)
```

#### 3. Llamada con `call`, `apply` o `bind`

Permite establecer el valor de `this` explícitamente.

```js
function saludar() {
  console.log(this.nombre);
}

saludar.call({ nombre: "Ana" }); // "Ana"
```

#### 4. En constructores (con `new`)

`this` apunta al **nuevo objeto creado**.

```js
function Animal(tipo) {
  this.tipo = tipo;
}

const perro = new Animal("perro");
```

#### 5. Arrow functions

`this` no es dinámico; **hereda** el `this` del contexto donde fue escrita.

```js
const obj = {
  nombre: "A",
  f: () => console.log(this),
};

obj.f(); // hereda this del entorno, no de obj
```

---

## 4. Relación entre Objects, Functions y `this`

- Las **funciones pueden actuar como métodos**, constructores o simples funciones.
- El valor de `this` permite a la función saber **qué objeto la está ejecutando**.
- Los objetos pueden contener funciones que utilizan `this` para acceder a sus propiedades.
- Las arrow functions se utilizan cuando no se desea un `this` propio.

### Ejemplo integrador

```js
const coche = {
  marca: "Toyota",
  mostrar() {
    console.log(this.marca);
  },
};

coche.mostrar(); // "Toyota"

const referencia = coche.mostrar;
referencia(); // undefined (strict) — pierde el contexto
```

---

## Resumen Completo (Puntos Clave)

- Un **objeto** es un contenedor flexible de propiedades y valores.
- Una **función** es un objeto especial con la capacidad de ejecutarse.
- Las funciones pueden tener propiedades como cualquier otro objeto.
- `this` **no se determina por la declaración**, sino por la **forma de invocación**.
- `this` apunta:

  - Al objeto que llama el método.
  - Al objeto global (o undefined en strict mode) en llamadas simples.
  - A un objeto específico con `call`, `apply` o `bind`.
  - Al nuevo objeto cuando se usa `new`.
  - Al `this` del contexto exterior en arrow functions.

- Objetos, funciones y `this` se combinan para formar los patrones de organización más comunes en JavaScript: métodos, constructores y programación orientada a objetos basada en prototipos.

---

---

Anterior Tema: [Conceptual Aside - By Value vs By Reference](./27.%20Conceptual%20Aside%20-%20By%20Value%20vs%20By%20Reference.md) | Siguiente Tema: [Conceptual Aside - Arrays - Collections of Anything](./29.%20Conceptual%20Aside%20-%20Arrays%20-%20Collections%20of%20Anything.md) | Volver al índice: [Índice Temático](../../README.md)
