# Conceptual Aside: By Value vs By Reference

## Explicaci√≥n esencial

JavaScript maneja la asignaci√≥n y el paso de datos a funciones de dos formas distintas, dependiendo del tipo de dato:

- **By Value (por valor)**
- **By Reference (por referencia)**

Esto determina si una variable contiene **una copia del valor** o **una referencia a un objeto en memoria**.

---

## 1. By Value (para tipos primitivos)

Los **tipos primitivos** (`string`, `number`, `boolean`, `undefined`, `null`, `symbol`, `bigint`) se copian **por valor**.

Esto significa que cada variable recibe **una copia independiente** del dato.

### Ejemplo:

```js
let a = 10;
let b = a;

b = 20;

console.log(a); // 10
console.log(b); // 20
```

- `a` y `b` son valores totalmente independientes.
- Cambiar `b` no afecta a `a`.

### Caracter√≠sticas clave:

- Cada variable almacena **su propio valor**.
- No comparten memoria.
- No existe forma de modificar el valor primitivo de otra variable indirectamente.

---

## 2. By Reference (para objetos)

Los **objetos**, incluyendo `arrays`, funciones y objetos literales, se asignan y pasan **por referencia**.

Esto significa que las variables almacenan **un puntero** (referencia) hacia el mismo objeto en memoria.

### Ejemplo:

```js
let x = { nombre: "Ana" };
let y = x;

y.nombre = "Carlos";

console.log(x.nombre); // "Carlos"
console.log(y.nombre); // "Carlos"
```

- `x` y `y` apuntan al **mismo objeto**.
- Cambiar propiedades a trav√©s de `y` tambi√©n modifica lo que ves desde `x`.

### Caracter√≠sticas clave:

- Varias variables pueden apuntar al mismo objeto.
- Modificar el objeto desde cualquiera de ellas afecta a todas.
- La referencia es lo que se copia, no el objeto.

---

## 3. Paso de argumentos a funciones

JavaScript **siempre** pasa argumentos por valor.
Lo que cambia es **qu√© tipo de valor** se copia:

- Si el valor es **primitivo**, se copia el valor.
- Si el valor es **objeto**, se copia la **referencia**.

### Ejemplo con primitivo:

```js
function cambiar(a) {
  a = 50;
}

let n = 10;
cambiar(n);

console.log(n); // 10
```

El valor original no cambia.

### Ejemplo con referencia:

```js
function modificar(obj) {
  obj.edad = 30;
}

let persona = { edad: 20 };
modificar(persona);

console.log(persona.edad); // 30
```

La referencia copiada apunta al mismo objeto, por eso se modifica.

---

## 4. Importante: reasignar ‚â† mutar

Reasignar una referencia **no** afecta a la variable original:

```js
function cambiar(obj) {
  obj = { edad: 99 }; // reasignaci√≥n interna
}

let persona = { edad: 20 };
cambiar(persona);

console.log(persona.edad); // 20
```

Solo las _mutaciones_ del objeto original tienen efecto, no las reasignaciones.

---

## üìå Resumen Completo (puntos clave)

- Los **primitivos** son asignados y pasados a funciones **por valor**.
- Los **objetos** son asignados y pasados **por referencia** (se copia la referencia).
- Dos variables pueden apuntar al mismo objeto si se copia la referencia.
- Cambiar un objeto a trav√©s de una variable afecta a todas las que compartan la misma referencia.
- JavaScript siempre pasa argumentos **por valor**, pero ese valor puede ser una referencia.
- Reasignar una variable dentro de una funci√≥n **no** afecta a la variable original.
- Mutar un objeto dentro de una funci√≥n **s√≠** afecta al original.

---

Anterior Tema: [Function Statements and Function Expressions](./26.%20Function%20Statements%20and%20Function%20Expressions.md) | Siguiente Tema: [Objects, Functions, and 'this'](./28.%20Objects%2C%20Functions%2C%20and%20'this'.md) | Volver al √≠ndice: [√çndice Tem√°tico](../../README.md)
