# üóÇÔ∏è Faking Namespaces en JavaScript

En JavaScript no existen _namespaces_ nativos (como en C#, Java o PHP). Antes de ES6, la √∫nica forma de organizar el c√≥digo y evitar colisiones de nombres era _simular_ namespaces usando **objetos**. A esto se le conoce como **Faking Namespaces**.

---

## ‚ù± ¬øQu√© es Faking Namespaces?

Consiste en agrupar funciones, variables y datos dentro de un **√∫nico objeto global**, evitando as√≠ m√∫ltiples elementos en el scope global.

```js
var App = {};

App.utils = {
  sumar: function (a, b) {
    return a + b;
  },
  restar: function (a, b) {
    return a - b;
  },
};
```

Con esto se evita esto:

```js
function sumar() {}
function restar() {}
var usuario = {};
var config = {};
```

Y todo queda bajo un solo nombre en el global:

```
window.App
```

---

## ‚ù± ¬øPor qu√© era importante?

### 1. Evitar colisiones en el _global scope_

JavaScript tiene un **global object** (window en navegadores).
Muchas funciones globales pod√≠an chocar entre s√≠:

```js
function init() {} // otra librer√≠a tambi√©n declara init()
```

Faking Namespaces reduce esto a un √∫nico identificador global.

---

## ‚ù± Importancia en los Frameworks (pre-ES6)

Frameworks y librer√≠as cl√°sicas como:

- jQuery (`$.fn`)
- AngularJS 1.x (`angular.module`)
- Backbone (`Backbone.Model`)
- ExtJS (`Ext`)

usaban **un solo nombre global** como ‚Äúra√≠z‚Äù de todo su ecosistema.

Ejemplo:

```js
Backbone.Model.extend(...)
```

Estas librer√≠as evitaban contaminar el global creando su propio "namespace ra√≠z".

---

# üîó Temas relacionados

(Explicados √∫nicamente en la medida en que se relacionan con **Faking Namespaces**)

---

## ‚ù± Revealing Module Pattern

El Revealing Module Pattern tambi√©n evita contaminaci√≥n global creando **un √∫nico objeto global**, pero encapsulando l√≥gica privada con un IIFE.

```js
var App = (function () {
  var privado = 10;

  function sumar(a, b) {
    return a + b;
  }

  return {
    sumar: sumar,
  };
})();
```

Se relaciona con Faking Namespaces porque **ambos limitan lo expuesto al global**.

---

## ‚ù± Minimizar contaminaci√≥n global

El objetivo principal de Faking Namespaces es **tener solo una variable global**, lo cual reduce:

- colisiones de nombres
- bugs dif√≠ciles de rastrear
- problemas entre librer√≠as distintas

Por eso era una pr√°ctica central en proyectos grandes antes de ES6.

---

## ‚ù± Faking Classes (antes de ES6)

Antes de `class`, las "clases" se implementaban as√≠:

```js
App.Persona = function (nombre) {
  this.nombre = nombre;
};
```

Los ‚Äúnamespaces‚Äù permit√≠an organizar estas _pseudo-clases_ dentro de un √∫nico objeto.

Se relaciona porque ambos responden a la necesidad de **organizar c√≥digo complejo sin contaminar el global**.

---

## ‚ù± Namespaces en proyectos grandes (arquitectura de carpetas)

En aplicaciones grandes, los namespaces ayudaban a:

- dividir c√≥digo en m√≥dulos separados
- reflejar la arquitectura de carpetas

Ejemplo:

```
/app
   /controllers
   /models
   /views
```

Pod√≠a reflejarse en un namespace:

```js
var App = {
  Controllers: {},
  Models: {},
  Views: {},
};
```

Era una forma primitiva de modularidad antes de ES6 Modules.

---

# ‚úîÔ∏è Resumen

- JavaScript no tiene namespaces nativos; antes se simulaban con objetos.
- Faking Namespaces agrupaba todo bajo un solo nombre global.
- Fue crucial para evitar colisiones y organizar c√≥digo en librer√≠as y frameworks.
- Se relaciona directamente con:

  - Revealing Module Pattern
  - Minimizar contaminaci√≥n global
  - Faking Classes antes de ES6
  - Arquitectura modular en proyectos grandes

- ES6 Modules y `import/export` reemplazaron esta necesidad, pero conocerla sigue siendo importante para entender c√≥digo legacy.
