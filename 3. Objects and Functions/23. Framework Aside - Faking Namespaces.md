# 🗂️ Faking Namespaces en JavaScript

### (Cómo simular namespaces sin soporte nativo)

En JavaScript no existen _namespaces_ nativos (como en C#, Java o PHP). Antes de ES6, la única forma de organizar el código y evitar colisiones de nombres era _simular_ namespaces usando **objetos**. A esto se le conoce como **Faking Namespaces**.

Sin embargo, se pueden **simular** para:

- Evitar colisiones de nombres
- Organizar mejor el código
- Agrupar funciones y variables relacionadas
- Mantener limpio el **global scope**

---

## ❱ ¿Qué es Faking Namespaces?

Consiste en agrupar funciones, variables y datos dentro de un **único objeto global**, evitando así múltiples elementos en el scope global.

```js
var App = {};

App.utils = {
  sumar: function (a, b) {
    return a + b;
  },
  restar: function (a, b) {
    return a - b;
  },
};
```

Con esto se evita esto:

```js
function sumar() {}
function restar() {}
var usuario = {};
var config = {};
```

Y todo queda bajo un solo nombre en el global:

```
window.App
```

---

## ❱ ¿Por qué se necesitan?

Antes de ES6 (y fuera de módulos), todas las variables y funciones globales comparten un único espacio.
Si dos scripts tienen:

```js
function init() {}
```

Uno sobrescribe al otro → **problema clásico**.

Para evitarlo, se simula un namespace creando un **objeto contenedor**.

### 1. Evitar colisiones en el _global scope_

JavaScript tiene un **global object** (window en navegadores).
Muchas funciones globales podían chocar entre sí:

```js
function init() {} // otra librería también declara init()
```

Faking Namespaces reduce esto a un único identificador global.

---

## 1. Namespace mediante un objeto simple

```js
var MiApp = {};

MiApp.utils = {
  saludar: function () {
    console.log("Hola");
  },
};

MiApp.config = {
  modo: "producción",
};

MiApp.utils.saludar();
```

- Todo queda dentro de `MiApp`.
- No contamina el global scope por fuera de ese nombre.
- Permite "subespacios": `MiApp.utils`, `MiApp.config`, etc.

---

## 2. Namespace con patrón "Module" (IIFE)

```js
var MiApp = (function () {
  let version = "1.0";

  function saludar() {
    console.log("Hola desde módulo");
  }

  return {
    saludar,
    version,
  };
})();
```

**Ventajas:**

- Variables internas (`version`) quedan **privadas**.
- Solo se expone lo que se retorna.
- Es un namespace **con encapsulación**.

**Uso:**

```js
MiApp.saludar();
console.log(MiApp.version);
```

### ❱ Revealing Module Pattern

El Revealing Module Pattern también evita contaminación global creando **un único objeto global**, pero encapsulando lógica privada con un IIFE.

```js
var App = (function () {
  var privado = 10;

  function sumar(a, b) {
    return a + b;
  }

  return {
    sumar: sumar,
  };
})();
```

Se relaciona con Faking Namespaces porque **ambos limitan lo expuesto al global**.

---

## 3. Namespaces anidados

```js
var App = App || {};
App.UI = App.UI || {};
App.UI.Forms = App.UI.Forms || {};

App.UI.Forms.validar = function () {
  console.log("Validando formulario");
};
```

Este patrón evita sobrescribir accidentalmente espacios ya creados.

### ❱ Namespaces en proyectos grandes (arquitectura de carpetas)

En aplicaciones grandes, los namespaces ayudaban a:

- dividir código en módulos separados
- reflejar la arquitectura de carpetas

**Ejemplo:**

```
/app
   /controllers
   /models
   /views
```

Podía reflejarse en un namespace:

```js
var App = {
  Controllers: {},
  Models: {},
  Views: {},
};
```

Era una forma primitiva de modularidad antes de ES6 Modules.

---

## 4. Namespace mediante función constructora

```js
function MyNamespace() {
  this.valor = 10;
}

MyNamespace.prototype.hola = function () {
  console.log("hola");
};

var ns = new MyNamespace();
ns.hola();
```

Menos común hoy, pero útil cuando se quiere instanciar múltiples namespaces independientes.

### ❱ Faking Classes (antes de ES6)

Antes de `class`, las "clases" se implementaban así:

```js
App.Persona = function (nombre) {
  this.nombre = nombre;
};
```

Los "namespaces" permitían organizar estas _pseudo-clases_ dentro de un único objeto.

Se relaciona porque ambos responden a la necesidad de **organizar código complejo sin contaminar el global**.

---

## 5. Namespace con ES6 Modules (la forma moderna)

> Técnicamente ya no es "faking"; ahora sí existen módulos reales.

**Archivo `utils.js`:**

```js
export function saludar() {
  console.log("Hola");
}
```

**Archivo `app.js`:**

```js
import { saludar } from "./utils.js";

saludar();
```

**Ventajas:**

- Cada archivo es su propio **namespace**.
- No contamina el global object.
- Es la forma recomendada actualmente.

---

## ❱ Importancia en los Frameworks (pre-ES6)

Frameworks y librerías clásicas como:

- jQuery (`$.fn`)
- AngularJS 1.x (`angular.module`)
- Backbone (`Backbone.Model`)
- ExtJS (`Ext`)

usaban **un solo nombre global** como "raíz" de todo su ecosistema.

**Ejemplo:**

```js
Backbone.Model.extend(...)
```

Estas librerías evitaban contaminar el global creando su propio "namespace raíz".

---

## 6. Desventaja de los Faked Namespaces

- Dependen de variables globales.
- Requieren disciplina para no sobrescribirlas.
- No ofrecen aislamiento total como los módulos ES6.

### ❱ Minimizar contaminación global

El objetivo principal de Faking Namespaces es **tener solo una variable global**, lo cual reduce:

- colisiones de nombres
- bugs difíciles de rastrear
- problemas entre librerías distintas

Por eso era una práctica central en proyectos grandes antes de ES6.

---

# 📌 Resumen

| Técnica               | Características                  |
| --------------------- | -------------------------------- |
| Objeto simple         | Agrupación básica, fácil de usar |
| IIFE / Module Pattern | Encapsulación + privacidad       |
| Namespaces anidados   | Escalabilidad y estructura       |
| Función constructora  | Para múltiples instancias        |
| ES6 Modules           | Solución moderna, nativa         |

## ✔️ Puntos clave

- JavaScript no tiene namespaces nativos; antes se simulaban con objetos.
- Faking Namespaces agrupaba todo bajo un solo nombre global.
- Fue crucial para evitar colisiones y organizar código en librerías y frameworks.
- Se relaciona directamente con:

  - Revealing Module Pattern
  - Minimizar contaminación global
  - Faking Classes antes de ES6
  - Arquitectura modular en proyectos grandes

- ES6 Modules y `import/export` reemplazaron esta necesidad, pero conocerla sigue siendo importante para entender código legacy.

---

---

Anterior tema: [Objects and Object Literals](./22.%20Objects%20and%20Object%20Literals.md) | Siguiente tema: [JSON and Object Literals](./24.%20JSON%20and%20Object%20Literals.md) | Volver al índice: [Índice Temático](../../README.md)
