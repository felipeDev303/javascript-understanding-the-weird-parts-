# üü¶ Function Invocation y The Execution Stack (JS)

## üü© Function Invocation (Invocaci√≥n de funci√≥n)

**Invocar una funci√≥n** significa **ejecutarla expl√≠citamente**, ya sea mediante:

```js
miFuncion();
```

o a trav√©s de eventos, callbacks, m√©todos, etc.

### üîç ¬øQu√© ocurre cuando se invoca una funci√≥n?

Cuando JavaScript encuentra una llamada como:

```js
sumar(2, 3);
```

sucede internamente:

1. **Se crea un nuevo Execution Context** (contexto de ejecuci√≥n) para esa funci√≥n.
2. Este nuevo contexto incluye:

   - Un **Variable Environment**
   - Un **Lexical Environment**
   - Un **this binding**

3. El Execution Context se coloca **encima de la Execution Stack** (tambi√©n llamada Call Stack).
4. JavaScript ejecuta el c√≥digo de la funci√≥n.
5. Al terminar, el contexto se **elimina de la pila**.

### Analogia neurocient√≠fica üß†

Invocar una funci√≥n es como cuando el cerebro **", llama" un procedimiento mental pregrabado**:

- Un jugador de ajedrez ve una jugada ‚Üí "invoca" un patr√≥n heur√≠stico aprendido.
- El cerebro activa ese "bloque" coherente de proceso.
- Cuando termina, vuelve al estado anterior.

Es como si la mente sacara de una ‚Äúpila‚Äù una subrutina cognitiva.

---

## üü¶ The Execution Stack (Call Stack)

La **Execution Stack** es una estructura interna donde JavaScript organiza **qu√© parte del programa est√° ejecutando en cada momento**.

‚û§ Es literalmente una **pila (Stack: LIFO)** de Execution Contexts.

### üìå ¬øC√≥mo funciona?

1. Primero se crea el **Global Execution Context** (GEC).
2. Cuando llamas a una funci√≥n, se crea un nuevo contexto y se **apila** arriba.
3. Si esa funci√≥n llama a otra funci√≥n, se crea otro contexto encima.
4. Cuando una funci√≥n termina, su contexto se **desapila**.
5. Cuando la pila vuelve a tener solo el global, el programa est√° ‚Äúen reposo‚Äù.

### Ejemplo:

```js
function a() {
  b();
}

function b() {
  console.log("Hola");
}

a();
```

Execution Stack paso a paso:

| Paso | Stack (arriba = ejecutando ahora) |
| ---- | --------------------------------- |
| 1    | GEC                               |
| 2    | GEC ‚Üí a()                         |
| 3    | GEC ‚Üí a() ‚Üí b()                   |
| 4    | (b termina) ‚Üí GEC ‚Üí a()           |
| 5    | (a termina) ‚Üí GEC                 |
| 6    | (fin del programa)                |

### Analogia neurocient√≠fica üß†

El Call Stack es parecido a c√≥mo el cerebro organiza **tareas encadenadas**:

- Quiero hacer caf√© ‚Üí
  Para eso debo hervir agua ‚Üí
  Para eso debo llenar la tetera ‚Üí
  Para eso debo abrir la llave‚Ä¶

Cada paso abre un subtarea que se coloca al frente de la atenci√≥n.

Cuando terminas una subtarea, vuelves a la anterior.

Es exactamente el comportamiento LIFO del Call Stack.

---

## üü™ Resumen r√°pido

| Concepto                | JS                                                | Analog√≠a Cerebro                              |
| ----------------------- | ------------------------------------------------- | --------------------------------------------- |
| **Function Invocation** | Ejecutar una funci√≥n creando un Execution Context | Activar un ‚Äúprocedimiento cognitivo‚Äù concreto |
| **Execution Stack**     | Pila que organiza los Execution Contexts          | Jerarqu√≠a de subtareas de la atenci√≥n humana  |
| **Modelo**              | LIFO                                              | Atenci√≥n enfocada en la √∫ltima tarea iniciada |
