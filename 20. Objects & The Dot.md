# Objects & The Dot

## Definición

**Object** en JavaScript es una colección de pares nombre-valor (name-value pairs).

Un objeto es una estructura de datos que almacena propiedades y métodos.

```js
let person = {
  name: "John",
  age: 30,
};
```

---

## Creación de Objetos

### 1. Object Literal (recomendado)

```js
let obj = {
  property: "value",
  method: function () {},
};
```

### 2. Constructor Object

```js
let obj = new Object();
obj.property = "value";
```

### 3. Object.create()

```js
let obj = Object.create(null);
obj.property = "value";
```

### 4. Constructor Function

```js
function Person(name) {
  this.name = name;
}
let person = new Person("John");
```

### 5. Class (ES6)

```js
class Person {
  constructor(name) {
    this.name = name;
  }
}
let person = new Person("John");
```

---

## Acceso a Propiedades

### Dot Notation (Notación de punto)

Sintaxis más común y legible:

```js
let person = {
  name: "John",
  age: 30,
};

// Lectura
console.log(person.name); // "John"
console.log(person.age); // 30

// Escritura
person.name = "Jane";
person.city = "Madrid"; // crea nueva propiedad
```

**Reglas:**

- Solo funciona con identificadores válidos
- No puede usar variables
- No puede usar nombres con espacios o caracteres especiales
- Más rápido que bracket notation

### Bracket Notation (Notación de corchetes)

Más flexible, permite nombres dinámicos:

```js
let person = {
  name: "John",
  "full name": "John Doe",
  age: 30,
};

// Lectura
console.log(person["name"]); // "John"
console.log(person["full name"]); // "John Doe"

// Con variables
let prop = "age";
console.log(person[prop]); // 30

// Con expresiones
console.log(person["na" + "me"]); // "John"
```

**Cuándo usar bracket notation:**

- Nombres de propiedades con espacios o caracteres especiales
- Nombres de propiedades almacenados en variables
- Nombres de propiedades generados dinámicamente
- Nombres de propiedades que son números

---

## Tabla Comparativa: Dot vs Bracket

| Característica            | Dot `.`        | Bracket `[]`      |
| ------------------------- | -------------- | ----------------- |
| **Sintaxis**              | `obj.property` | `obj["property"]` |
| **Legibilidad**           | Más clara      | Menos clara       |
| **Variables**             | No soporta     | Sí soporta        |
| **Espacios en nombre**    | No             | Sí                |
| **Caracteres especiales** | No             | Sí                |
| **Números como keys**     | No             | Sí                |
| **Expresiones**           | No             | Sí                |
| **Performance**           | Más rápido     | Más lento         |
| **Uso recomendado**       | Por defecto    | Casos especiales  |

---

## Propiedades de Objetos

### Propiedades Simples

```js
let car = {
  brand: "Toyota",
  model: "Corolla",
  year: 2020,
};
```

### Propiedades Computadas (ES6)

```js
let prop = "color";
let car = {
  [prop]: "red",
  ["max" + "Speed"]: 180,
};

console.log(car.color); // "red"
console.log(car.maxSpeed); // 180
```

### Propiedades Shorthand (ES6)

```js
let name = "John";
let age = 30;

// Forma antigua
let person1 = {
  name: name,
  age: age,
};

// ES6 shorthand
let person2 = {
  name,
  age,
};
```

### Métodos

```js
let person = {
  name: "John",

  // Método tradicional
  greet: function () {
    return "Hello, " + this.name;
  },

  // Método shorthand (ES6)
  sayBye() {
    return "Bye, " + this.name;
  },
};

person.greet(); // "Hello, John"
person.sayBye(); // "Bye, John"
```

---

## Propiedades Especiales

### Symbols como Keys (ES6)

```js
let id = Symbol("id");
let user = {
  name: "John",
  [id]: 12345,
};

console.log(user[id]); // 12345
console.log(user.id); // undefined
```

### Getters y Setters

```js
let user = {
  firstName: "John",
  lastName: "Doe",

  get fullName() {
    return `${this.firstName} ${this.lastName}`;
  },

  set fullName(value) {
    [this.firstName, this.lastName] = value.split(" ");
  },
};

console.log(user.fullName); // "John Doe"
user.fullName = "Jane Smith";
console.log(user.firstName); // "Jane"
```

---

## Operaciones con Objetos

### Verificar Existencia de Propiedad

```js
let obj = { name: "John", age: 30 };

// in operator
"name" in obj; // true
"city" in obj; // false

// hasOwnProperty
obj.hasOwnProperty("name"); // true
obj.hasOwnProperty("toString"); // false (heredada)

// undefined check (no recomendado)
obj.name !== undefined; // true
```

### Eliminar Propiedades

```js
let obj = { name: "John", age: 30 };

delete obj.age;
console.log(obj.age); // undefined
console.log("age" in obj); // false
```

### Iterar sobre Propiedades

```js
let person = { name: "John", age: 30, city: "Madrid" };

// for...in (incluye propiedades heredadas)
for (let key in person) {
  console.log(key + ": " + person[key]);
}

// Object.keys() (solo propias)
Object.keys(person).forEach((key) => {
  console.log(key + ": " + person[key]);
});

// Object.entries() (ES8)
Object.entries(person).forEach(([key, value]) => {
  console.log(key + ": " + value);
});

// Object.values() (ES8)
Object.values(person).forEach((value) => {
  console.log(value);
});
```

---

## Métodos Útiles de Object

### Object.assign()

Copia propiedades de objetos:

```js
let target = { a: 1 };
let source1 = { b: 2 };
let source2 = { c: 3 };

Object.assign(target, source1, source2);
console.log(target); // { a: 1, b: 2, c: 3 }

// Clonar objeto (shallow copy)
let clone = Object.assign({}, original);
```

### Object.freeze()

Hace objeto inmutable:

```js
let obj = { name: "John" };
Object.freeze(obj);

obj.name = "Jane"; // No tiene efecto
obj.age = 30; // No se añade
delete obj.name; // No se elimina

console.log(obj.name); // "John"
```

### Object.seal()

Previene añadir/eliminar propiedades, pero permite modificar:

```js
let obj = { name: "John" };
Object.seal(obj);

obj.name = "Jane"; // Funciona
obj.age = 30; // No se añade
delete obj.name; // No se elimina

console.log(obj.name); // "Jane"
```

### Object.defineProperty()

Define o modifica propiedades con configuración avanzada:

```js
let obj = {};

Object.defineProperty(obj, "name", {
  value: "John",
  writable: false, // no se puede modificar
  enumerable: true, // aparece en for...in
  configurable: false, // no se puede eliminar ni reconfigurar
});

obj.name = "Jane"; // No tiene efecto
console.log(obj.name); // "John"
```

---

## Property Descriptors

Cada propiedad tiene atributos internos:

```js
let obj = { name: "John" };

let descriptor = Object.getOwnPropertyDescriptor(obj, "name");
console.log(descriptor);
/* {
  value: "John",
  writable: true,
  enumerable: true,
  configurable: true
} */
```

**Atributos:**

- `value`: valor de la propiedad
- `writable`: si se puede modificar
- `enumerable`: si aparece en iteraciones (for...in, Object.keys)
- `configurable`: si se puede eliminar o reconfigurar
- `get`: función getter
- `set`: función setter

---

## Prototype Chain y Propiedades

```js
let obj = { name: "John" };

// Propias
obj.hasOwnProperty("name"); // true
obj.hasOwnProperty("toString"); // false

// Heredadas del prototipo
"toString" in obj; // true
obj.toString(); // "[object Object]"

// Ver prototipo
Object.getPrototypeOf(obj); // Object.prototype
obj.__proto__; // Object.prototype (no recomendado)
```

---

## Objetos Anidados

```js
let company = {
  name: "TechCorp",
  address: {
    street: "Main St",
    city: "Madrid",
    country: {
      name: "Spain",
      code: "ES",
    },
  },
};

// Acceso anidado
console.log(company.address.city); // "Madrid"
console.log(company.address.country.name); // "Spain"

// Optional chaining (ES2020)
console.log(company.address?.city); // "Madrid"
console.log(company.contact?.email); // undefined (no error)
console.log(company.contact?.email ?? "No email"); // "No email"
```

---

## Destructuring (ES6)

```js
let person = {
  name: "John",
  age: 30,
  city: "Madrid",
};

// Destructuring básico
let { name, age } = person;
console.log(name); // "John"

// Renombrar variables
let { name: firstName, age: years } = person;
console.log(firstName); // "John"

// Valores por defecto
let { name, country = "Spain" } = person;
console.log(country); // "Spain"

// Destructuring anidado
let user = {
  name: "John",
  address: {
    city: "Madrid",
  },
};

let {
  address: { city },
} = user;
console.log(city); // "Madrid"
```

---

## Spread Operator (ES6)

```js
let obj1 = { a: 1, b: 2 };
let obj2 = { c: 3, d: 4 };

// Combinar objetos
let combined = { ...obj1, ...obj2 };
console.log(combined); // { a: 1, b: 2, c: 3, d: 4 }

// Clonar objeto (shallow)
let clone = { ...obj1 };

// Sobrescribir propiedades
let updated = { ...obj1, b: 10, e: 5 };
console.log(updated); // { a: 1, b: 10, e: 5 }
```

---

## Rest Operator (ES6)

```js
let person = {
  name: "John",
  age: 30,
  city: "Madrid",
  country: "Spain",
};

// Extraer algunas propiedades
let { name, ...rest } = person;
console.log(name); // "John"
console.log(rest); // { age: 30, city: "Madrid", country: "Spain" }
```

---

## Funcionamiento Interno

### Almacenamiento en Memoria

Los objetos se almacenan por referencia:

```js
let obj1 = { name: "John" };
let obj2 = obj1; // Misma referencia

obj2.name = "Jane";
console.log(obj1.name); // "Jane" (ambos apuntan al mismo objeto)

// Comparación por referencia
let a = { x: 1 };
let b = { x: 1 };
a === b; // false (diferentes referencias)

let c = a;
a === c; // true (misma referencia)
```

### Property Access Algorithm

Cuando accedes a `obj.property`:

1. Busca en propiedades propias del objeto
2. Si no existe, busca en `obj.__proto__`
3. Continúa por la cadena de prototipos
4. Si no se encuentra en ningún lado, devuelve `undefined`

```js
let obj = { name: "John" };

// 1. Busca "name" en obj → encontrada
obj.name; // "John"

// 2. Busca "toString" en obj → no encontrada
// 3. Busca en obj.__proto__ (Object.prototype) → encontrada
obj.toString(); // "[object Object]"

// 4. Busca "xyz" en obj → no encontrada
// 5. Busca en toda la cadena → no encontrada
obj.xyz; // undefined
```

---

## Performance

### Dot vs Bracket

```js
let obj = { name: "John" };

// Dot notation (más rápido)
obj.name; // Optimizado por motores JS

// Bracket notation (más lento)
obj["name"]; // Requiere evaluar la expresión string
```

### Object Shapes (Hidden Classes)

Los motores JS optimizan objetos con la misma estructura:

```js
// Bien: misma forma (shape)
function createPerson(name, age) {
  return { name, age }; // Siempre same shape
}

let p1 = createPerson("John", 30);
let p2 = createPerson("Jane", 25);

// Mal: diferentes formas
let p3 = { name: "Bob" };
p3.age = 40; // Shape cambia dinámicamente
```

---

## Tabla: Métodos de Object

| Método                              | Descripción                          | Ejemplo                                       |
| ----------------------------------- | ------------------------------------ | --------------------------------------------- |
| `Object.keys()`                     | Array de claves propias enumerables  | `Object.keys(obj)`                            |
| `Object.values()`                   | Array de valores propios enumerables | `Object.values(obj)`                          |
| `Object.entries()`                  | Array de pares [clave, valor]        | `Object.entries(obj)`                         |
| `Object.assign()`                   | Copia propiedades a objeto destino   | `Object.assign(target, src)`                  |
| `Object.create()`                   | Crea objeto con prototipo específico | `Object.create(proto)`                        |
| `Object.freeze()`                   | Hace objeto inmutable                | `Object.freeze(obj)`                          |
| `Object.seal()`                     | Previene añadir/eliminar propiedades | `Object.seal(obj)`                            |
| `Object.defineProperty()`           | Define/modifica propiedad con config | `Object.defineProperty(obj, "key", {})`       |
| `Object.getOwnPropertyDescriptor()` | Obtiene descriptor de propiedad      | `Object.getOwnPropertyDescriptor(obj, "key")` |
| `Object.getPrototypeOf()`           | Obtiene prototipo                    | `Object.getPrototypeOf(obj)`                  |
| `Object.setPrototypeOf()`           | Establece prototipo                  | `Object.setPrototypeOf(obj, proto)`           |

---

## Mejores Prácticas

1. **Usar dot notation por defecto**

   ```js
   // Bien
   obj.name;

   // Solo cuando sea necesario
   obj["property-with-dash"];
   obj[variableName];
   ```

2. **Evitar modificar `__proto__` directamente**

   ```js
   // Mal
   obj.__proto__ = newProto;

   // Bien
   Object.setPrototypeOf(obj, newProto);
   ```

3. **Usar const para objetos que no se reasignan**

   ```js
   // Bien (el contenido puede cambiar)
   const person = { name: "John" };
   person.age = 30; // OK

   // Mal
   person = { name: "Jane" }; // Error
   ```

4. **Clonar objetos correctamente**

   ```js
   // Shallow copy
   let clone1 = { ...original };
   let clone2 = Object.assign({}, original);

   // Deep copy (para objetos anidados)
   let deepClone = JSON.parse(JSON.stringify(original));
   // o usar structuredClone() (ES2022)
   let deepClone2 = structuredClone(original);
   ```

5. **Validar existencia de propiedades anidadas**

   ```js
   // Mal
   if (obj.user.address.city) {
   } // Error si user o address es undefined

   // Bien (ES2020)
   if (obj.user?.address?.city) {
   }
   ```

---

## Resumen

**Objects:**

- Colección de pares nombre-valor
- Se almacenan por referencia en memoria
- Dos formas de acceso: dot (`.`) y bracket (`[]`)

**Dot Notation:**

- Más rápida y legible
- Solo para identificadores válidos
- Uso recomendado por defecto

**Bracket Notation:**

- Permite nombres dinámicos y variables
- Soporta caracteres especiales y espacios
- Necesaria para acceso dinámico

**Características modernas (ES6+):**

- Computed properties: `{ [expr]: value }`
- Shorthand: `{ name, age }`
- Destructuring: `let { x, y } = obj`
- Spread: `{ ...obj1, ...obj2 }`
- Optional chaining: `obj?.prop?.nested`

**Métodos clave:**

- `Object.keys/values/entries()`: iterar propiedades
- `Object.assign()`: copiar/combinar
- `Object.freeze/seal()`: inmutabilidad
- `Object.create()`: crear con prototipo

---

Anterior tema: [Default Values](./19.%20Default%20Values.md) | Siguiente tema: [Object Literals](./20.%20Object%20Literals.md) | Volver al índice: [Índice Temático](./README.md)
