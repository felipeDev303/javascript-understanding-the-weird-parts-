# ğŸŸ¦ Asynchronous Callbacks en JavaScript

## ğŸŸ© 1. Â¿QuÃ© es un Callback?

Un **callback** es una funciÃ³n que se pasa como argumento a otra funciÃ³n para ser ejecutada mÃ¡s adelante.

```js
function greet(name, callback) {
  callback(`Hola, ${name}`);
}
```

Hasta aquÃ­, todo es sÃ­ncrono.

---

## ğŸŸ¦ 2. Â¿QuÃ© hace que un Callback sea _asÃ­ncrono_?

Un **asynchronous callback** es un callback que **NO se ejecuta de inmediato**, sino que es enviado a:

- el **Web API** (navegador) o
- el **libuv** (Node.js)

â€¦y se ejecuta _despuÃ©s_, cuando el Event Loop lo permite.

Ejemplos tÃ­picos:

- `setTimeout`
- `addEventListener`
- peticiones con `fetch`
- operaciones de I/O en Node

```js
console.log("Inicio");

setTimeout(() => {
  console.log("Esto ocurre despuÃ©s");
}, 1000);

console.log("Fin");
```

Salida:

```
Inicio
Fin
Esto ocurre despuÃ©s
```

---

## ğŸŸ§ 3. El Modelo Mental Definitivo: **El Restaurant**

El JavaScript runtime funciona como un restaurant con:

### ğŸ”¹ 1. **El Chef**

â†’ _El motor JavaScript (call stack)_
â†’ Solo puede cocinar un plato a la vez (single-threaded)

### ğŸ”¹ 2. **Meseros**

â†’ _Web APIs o Node APIs_
â†’ Se llevan tareas â€œcomplicadasâ€ a la cocina secundaria

### ğŸ”¹ 3. **La Campana del Chef** (Event Queue)

â†’ Donde los meseros dejan Ã³rdenes listas para ser servidas

### ğŸ”¹ 4. **El Supervisor** (Event Loop)

â†’ Supervisa la campana y el chef
â†’ Cuando el chef estÃ¡ libre, entrega la prÃ³xima tarea

---

## ğŸŸ¦ 4. Â¿QuÃ© ocurre realmente cuando usas un Asynchronous Callback?

Ejemplo:

```js
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

console.log("3");
```

### ğŸ”¥ Paso a paso con el modelo del Restaurant:

1. `console.log("1")`
   â¡ El chef lo ejecuta inmediatamente.

2. `setTimeout(..., 0)`
   â¡ El mesero toma la orden y se la lleva al Web API.
   â¡ El callback queda **fuera del chef**, esperando.

3. `console.log("3")`
   â¡ El chef lo ejecuta inmediatamente.

4. Mientras tantoâ€¦
   â¡ El Web API termina el temporizador (aunque sea 0 ms).
   â¡ Pone el callback en **la campana** (event queue).

5. El Event Loop revisa:

> â€œÂ¿El chef estÃ¡ libre?â€
> âœ” SÃ­, entonces entrega el callback.

6. Callback ejecutado â†’ se imprime `"2"`

Salida final:

```
1
3
2
```

---

## ğŸŸ© 5. Â¿Por quÃ© todo esto?

### Porque JavaScript es _single-threaded_ pero quiere ser _no bloqueante_.

Si JavaScript fuera totalmente sÃ­ncrono:

- una peticiÃ³n HTTP bloquearÃ­a la app
- una lectura de archivo congelarÃ­a la UI
- una animaciÃ³n se trabarÃ­a si algo se demorara

Los **asynchronous callbacks** permiten:

âœ” alta concurrencia
âœ” interfaces fluidas
âœ” servidores Node rÃ¡pidos
âœ” evitar bloqueos

---

## ğŸŸ¦ 6. Scope y Execution Context de los Callbacks

Cuando un callback se ejecuta:

1. se crea un nuevo **Function Execution Context**
2. con su propio:

   - Variable Environment
   - Lexical Environment
   - this binding

3. pero conserva acceso a su **Scope Chain original** (cierre/closure)

```js
function outer() {
  let x = 10;

  setTimeout(() => {
    console.log(x);
  }, 1000);
}

outer();
```

Aunque `outer()` ya terminÃ³, el callback aÃºn recuerda `x`.

> Modelo mental:
> Es como si el callback llevara una **mochila** con las variables del lugar donde fue creado.

---

## ğŸŸ§ 7. El problema clÃ¡sico: Callback Hell

Antes de Promises y async/await, el flujo asincrÃ³nico se veÃ­a asÃ­:

```js
step1(function () {
  step2(function () {
    step3(function () {
      step4(function () {
        console.log("Completado");
      });
    });
  });
});
```

DifÃ­cil de leer, mantener y depurar.

Esto llevÃ³ a ES6 a incluir:

- Promises
- luego async/await (ES2017)

---

# ## ğŸŸ© 8. CÃ³mo saber si algo usa Asynchronous Callbacks

| FunciÃ³n            | AsÃ­ncrono | Por quÃ©                 |
| ------------------ | --------- | ----------------------- |
| `setTimeout`       | SÃ­        | lo maneja Web API       |
| `fetch`            | SÃ­        | networking es asÃ­ncrono |
| `addEventListener` | SÃ­        | se ejecuta despuÃ©s      |
| `console.log`      | No        | sÃ­ncrono                |
| `math operations`  | No        | call stack directo      |
| `JSON.parse`       | No        | bloqueante              |

---

## ğŸŸ¦ 9. Ejemplo final muy claro

```js
console.log("Antes");

setTimeout(() => {
  console.log("Durante (asincrÃ³nico)");
}, 0);

console.log("DespuÃ©s");
```

### Flujo real:

```
Chef ejecuta "Antes"
Mesero recibe setTimeout
Chef ejecuta "DespuÃ©s"
Mesero devuelve callback a la campana
Supervisor (Event Loop) lo entrega al chef
Chef ejecuta "Durante"
```

---

## ğŸŸª Resumen definitivo

### âœ” Los _callbacks_ son funciones pasadas como argumentos.

### âœ” Los _asynchronous callbacks_ se ejecutan despuÃ©s, no de inmediato.

### âœ” El navegador/Node hace el trabajo en segundo plano.

### âœ” El Event Loop coordina cuÃ¡ndo se ejecutan.

### âœ” Son esenciales para no bloquear la interfaz o el servidor.

### âœ” Conservan su Scope Chain original por medio de closures.

### âœ” Fueron la base de la asincronÃ­a antes de Promises y `async/await`.

---

Anterior tema: [Scope, ES6 & let](./9.%20Scope%2C%20ES6%20%26%20let.md) | Siguiente tema: [Dynamic Typing](./11.%20Dynamic%20Typing.md) | Volver al Ã­ndice: [Ãndice TemÃ¡tico](./README.md)
