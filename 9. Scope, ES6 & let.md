# ğŸŸ¦ Scope, ES6 y `let`

JavaScript introdujo `let` y `const` en ES6, cambiando cÃ³mo funciona el scope.

Big Words Alert

## ğŸŸ© 1. Â¿QuÃ© es el _Scope_?

El **scope** es _el Ã¡rea en la que una variable es visible y accesible_.
Determina:

- dÃ³nde puedes usar una variable,
- cuÃ¡nto tiempo vive,
- y quiÃ©n tiene permiso para leerla o modificarla.

Piensa en el scope como **una habitaciÃ³n**:
si una variable estÃ¡ dentro de la habitaciÃ³n, solo quienes estÃ¡n dentro pueden verla.

---

## ğŸŸ¦ 2. Tipos de Scope en JavaScript

JavaScript tiene tres tipos principales:

### 1) **Global Scope**

Variables accesibles desde _cualquier parte_ del programa.

```js
let x = 10; // global
```

> Modelo mental:
> **La casa completa**. Todos pueden ver las variables globales.

---

### 2) **Function Scope**

Variables creadas dentro de una funciÃ³n solo pueden ser usadas dentro de ella.

```js
function test() {
  let y = 20;
}
console.log(y); // âŒ Error
```

> Modelo mental:
> **Una habitaciÃ³n privada**: solo quienes estÃ¡n dentro tienen acceso.

---

### 3) **Block Scope** (nuevo desde ES6)

Variables declaradas con `let` y `const` solo son accesibles dentro del bloque `{ }`.

```js
{
  let z = 30;
}
console.log(z); // âŒ Error
```

> Modelo mental:
> **Un cajÃ³n dentro de la habitaciÃ³n**.
> Solo quien abra ese cajÃ³n puede ver lo que hay dentro.

---

## ğŸŸ© 3. El cambio crucial de ES6: `let` introduce _Block Scope_

Antes de ES6, solo tenÃ­amos `var`, que **NO respeta el bloque**.

```js
if (true) {
  var a = 10;
}
console.log(a); // âœ” 10
```

Con ES6:

```js
if (true) {
  let b = 20;
}
console.log(b); // âŒ Error
```

### âœ” `let` y `const` respetan el bloque

âœ” `var` NO respeta el bloque (solo respeta la funciÃ³n)

Esto es una de las diferencias mÃ¡s importantes de ES6.

---

## ğŸŸ¦ 4. Hoisting con `let`: crea el TDZ (Temporal Dead Zone)

Las variables `let` **tambiÃ©n son hoisted**, pero _no pueden usarse antes de estar declaradas_.

Ejemplo:

```js
console.log(a); // âŒ Error
let a = 10;
```

Â¿Por quÃ©?

Porque existe un periodo entre:

- el inicio del scope
- y la lÃ­nea donde declaras la variable

â€¦durante el cual la variable existe **pero no estÃ¡ inicializada**.

Ese periodo es la **TDZ â€” Temporal Dead Zone**.

### ğŸ§  Modelo mental

Piensa en `let` como una caja:

- La caja estÃ¡ **reservada** en el cuarto (hoisting),
- Pero estÃ¡ **cerrada con llave** hasta que el cÃ³digo llega a la declaraciÃ³n.
- Intentar acceder antes â†’ error.

---

## ğŸŸ© 5. Modelo Mental Definitivo (muy poderoso)

### **El mundo del cÃ³digo es una casa.**

Dentro tienes:

```
La casa (global scope)
â””â”€â”€ HabitaciÃ³n (function scope)
    â””â”€â”€ CajÃ³n (block scope)
```

Ahora:

- `var` = vive en la **casa** o en la **habitaciÃ³n**
  âœ No puede vivir dentro del cajÃ³n
  âœ Es como un objeto grande que no cabe en el cajÃ³n

- `let` y `const` = pueden vivir **dentro del cajÃ³n**
  âœ Son objetos pequeÃ±os, privados y ordenados
  âœ Solo existen dentro de ese espacio

- TDZ = el cajÃ³n estÃ¡ **cerrado con llave** hasta que la variable se declara
  âœ No puedes usar su contenido antes

### Recurda:

âœ” Let/const â†’ viven en cajones (bloques)
âœ” Var â†’ no cabe en los cajones (solo funciÃ³n o global)
âœ” TDZ â†’ la llave aparece solo cuando llegas a la declaraciÃ³n
âœ” Scope â†’ cada espacio define lo que se puede ver

---

## ğŸŸ¦ 6. Ejemplos claros y Ãºtiles

### Ejemplo 1: block scope correcto

```js
for (let i = 0; i < 3; i++) {
  console.log(i);
}
console.log(i); // âŒ Error
```

Cada iteraciÃ³n crea un **nuevo cajÃ³n**.

---

### Ejemplo 2: var ignorando el bloque

```js
if (true) {
  var x = 100;
}
console.log(x); // âœ” 100
```

`var` se va a la **habitaciÃ³n**, no al cajÃ³n.

---

### Ejemplo 3: TDZ en acciÃ³n

```js
console.log(msg); // âŒ Error
let msg = "Hola mundo";
```

Caja creada pero **cerrada** hasta la lÃ­nea donde se declara.

---

### Ejemplo 4: let dentro de funciÃ³n y bloque

```js
function demo() {
  let a = 1;

  if (true) {
    let a = 2; // nuevo â€˜aâ€™ dentro del cajÃ³n
    console.log(a); // 2
  }

  console.log(a); // 1
}
```

Cada espacio tiene su propio â€œcajÃ³nâ€ o â€œhabitaciÃ³nâ€.

---

## ğŸŸ¨ ConclusiÃ³n

### âœ” `let` trajo un modelo de scope mÃ¡s claro y seguro

### âœ” Evita bugs que `var` generaba durante aÃ±os

### âœ” Introduce el Block Scope real

### âœ” Junto con Ã©l aparece la TDZ

### âœ” Te permite razonar en niveles:

```
global â†’ function â†’ block
```

---

Anterior tema: [The Scope Chain](./8.%20The%20Scope%20Chain.md) | Siguiente tema: [Asynchronous Callbacks](./10.%20Asynchronous%20Callbacks.md) | Volver al Ã­ndice: [Ãndice TemÃ¡tico](./README.md)
